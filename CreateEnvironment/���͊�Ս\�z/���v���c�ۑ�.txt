
kibanaのクエリで以下を検索
pgsql AND "192.168.0.120" AND select AND "select * from pgbench_accounts where aid=2;"

method:SELECT AND ip:192.168.0.119 NOT(query:SELECT pg_last_xlog_replay_location) NOT(query:SELECT pg_current_xlog_location) NOT(query:SELECT pg_is_in_recovery)



pgbench -h 192.168.0.118 -p 9999 -U repl_user -c 10 -t 1000 testdb


pgbenchには、起動時に指定する様々なオプションがあります。 ここでは、pgbenchを使う上で重要なオプションのみ抜粋して紹介します。


-h 	PostgreSQL(postmaster)が起動しているホスト名を指定します。省略時には自ホストへUnix domain socketで接続します。 
-p 	PostgreSQL(postmaster)が起動しているポート番号を指定します。
	省略時にはPostgreSQL(postmaster)がデフォルトで使用している5432ポートが指定されたものとみなされます。 
-i 	ベンチマークテストで使用するデータベースを初期化します。 
-s 	スケーリングファクターを指定します。
	データベースを初期化するときに使用し、スケーリングファクター*10万件のデータが作成されます。
	省略時には1が指定されたとみなされます。 
-c 	同時に実行するクライアントの数を指定します。省略時には1が指定されたものとみなされます。 
-t 	1クライアントが実行するトランザクションの数を指定します。省略時には10が指定されたものとみなされます。 
-S 	このオプションを指定すると検索処理のテストを行ないます。他の処理は行なわれません。 
-N 	このオプションを指定すると通常のテストから一部の更新処理を省いたテストが行なわれます。 
-d 	このオプションを指定すると、テストの経過など様々な情報が表示されます。
	しかし、情報を大量に表示する処理が行なわれるため、若干テスト結果が悪化してしまいます。 

-l を指定してpgbenchを実行すると、カレントディレクトリに"pgbench_log.xxx"というファイルが出来ます。ここで"xxx"の部分はプロセスIDという数字で、たいていの場合は実行ごとに異なる数字になります。

たとえば、
pgbench -S -n -p 5432 -T 60 -l -c 1 test

を実行すると、pgbench_log.27083というファイルができて、以下のような内容になっています。
0 0 4433 0 1273412718 754410
0 1 573 0 1273412718 755063
0 2 546 0 1273412718 755625
0 3 530 0 1273412718 756171
:
:

1行に1トランザクションのデータが記述されています。各行の数字は左から以下のようになります。
 クライアントID。0から始まり、pgbenchからPostgreSQLの接続に対応
 トランザクションID。0から始まり、各クライアントID内で実行した順に番号が振られます。
マイクロ秒単位のトランザクション処理時間。
スクリプトファイル番号。-fを指定したときだけ意味があります。

最後の2つの数字はトランザクションの終了時刻をマイクロ秒単位の精度で表します。最初の数字は1970年1月1日からの経過秒数、最後の数字はマイクロ秒です。



http://192.168.0.118:5601/

http://lets.postgresql.jp/documents/technical/contrib/pgbench/




